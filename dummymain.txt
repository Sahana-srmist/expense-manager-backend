
from fastapi import FastAPI, HTTPException, Depends
from typing import List
from database import get_db_connection
from schemas import ExpenseIn, ExpenseOut
import psycopg2.extras
from fastapi.responses import Response
from fastapi.security import HTTPBasic, HTTPBasicCredentials
import secrets
from fastapi.responses import StreamingResponse
import csv
import io
from datetime import datetime
import bcrypt

security = HTTPBasic()


app = FastAPI(
    title="EXPENSE MANAGER",          # appears in swagger UI
    description="Track and manage expenses with user authentication.",
    version="1.0.0"
)

def get_current_user(credentials: HTTPBasicCredentials = Depends(security)):
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT password FROM users WHERE username = %s", (credentials.username,))
        result = cur.fetchone()
        cur.close()
        conn.close()

        if result:
            db_password = result[0]
            print("DB password:", db_password)
            print("DB password type:", type(db_password))
            print("User entered password:", credentials.password)

            if bcrypt.checkpw(credentials.password.encode(), db_password if isinstance(db_password, bytes) else db_password.encode()):
                return credentials.username
            else:
                print("Password mismatch")
                raise HTTPException(status_code=401, detail="Incorrect password")
        else:
            print("Username not found")
            raise HTTPException(status_code=401, detail="User not found")

    except HTTPException as he:
        raise he  # Re-raise your expected errors (401)
    except Exception as e:
        print("get_current_user error:", e)
        raise HTTPException(status_code=500, detail="Server error in authentication")


@app.get("/")
def root():
    return {"message": "Welcome to the PostgreSQL Expense Manager API"}

@app.post("/register")
def register_user(username: str, password: str):
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
        cur.execute("INSERT INTO users (username, password) VALUES (%s, %s)", (username, hashed.decode()))
        conn.commit()
        return {"message": "User registered successfully!"}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail="Username already exists.")
    finally:
        cur.close()
        conn.close()
    

@app.post("/login")
def login(current_user: str = Depends(get_current_user)):
    return {"message": f"Welcome, {current_user}!"}


@app.post("/add", response_model=dict)
def add_expense(expense: ExpenseIn, current_user: str = Depends(get_current_user)):
    if current_user != expense.username:
        raise HTTPException(status_code=403, detail="Unauthorized user")
          # Convert DD-MM-YYYY to datetime.date
    try:
        date_obj = datetime.strptime(expense.date, "%d-%m-%Y").date()
    except ValueError:
        raise HTTPException(status_code=400, detail="Date format must be DD-MM-YYYY")

    conn = get_db_connection()
    cur = conn.cursor()

    try:
        if expense.amount < 0 or expense.amount > 99999999:
            raise HTTPException(status_code=400, detail="Invalid amount range.")

    
        cur.execute(
            """
            INSERT INTO expenses (username, reason, amount, date)
            VALUES (%s, %s, %s, %s)
            """,
            (expense.username, expense.reason, expense.amount, date_obj)
        )
        conn.commit()

        return {
            "message": "Expense added successfully",
            "data": expense.dict()  
        }
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()


@app.get("/expenses/{username}", response_model=List[ExpenseOut])
def get_expenses(username: str, current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")

    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)

    cur.execute(
        "SELECT sno, username, reason, amount, date FROM expenses WHERE LOWER(username) = LOWER(%s)",
        (username,)
    )

    rows = cur.fetchall()
    cur.close()
    conn.close()

    if not rows:
        raise HTTPException(status_code=404, detail="No expenses found.")

    return [ExpenseOut(**dict(row)) for row in rows]


@app.get("/search/", response_model=List[ExpenseOut])
def search_by_reason(username: str, reason: str,current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    cur.execute(
        "SELECT sno, username, reason, amount, date FROM expenses WHERE LOWER(reason) = LOWER(%s) AND LOWER(username) = LOWER(%s)",
        (reason, username)
    )

    rows = cur.fetchall()
    cur.close()
    conn.close()
    if not rows:
        raise HTTPException(status_code=404, detail="No matching expenses.")
    return [ExpenseOut(**dict(row)) for row in rows]

@app.get("/search/date", response_model=List[ExpenseOut])
def search_by_date(username: str, date: str, current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")

    # Validate date format
    try:
        search_date = datetime.strptime(date, "%d-%m-%Y").date()
    except ValueError:
        raise HTTPException(status_code=400, detail="Date format should be DD-MM-YYYY")

    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
    cur.execute(
        """
        SELECT sno, username, reason, amount, date
        FROM expenses
        WHERE username = %s AND date = %s
        """,
        (username, search_date)
    )
    rows = cur.fetchall()
    cur.close()
    conn.close()

    if not rows:
        raise HTTPException(status_code=404, detail="No expenses found on this date.")

    return [ExpenseOut(**dict(row)) for row in rows]

@app.delete("/delete/", response_model=dict)
def delete_by_reason(username: str, reason: str,current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute(
        "DELETE FROM expenses WHERE LOWER(reason) = LOWER(%s) AND LOWER(username) = LOWER(%s)",
        (reason, username)
    )
    conn.commit()
    cur.close()
    conn.close()
    return {"message": f"Deleted all expenses for reason: {reason}"}

@app.get("/summary/{username}", response_model=dict)
def get_summary(username: str,current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute(
            "SELECT amount FROM expenses WHERE LOWER(username) = LOWER(%s)",
            (username,)
        )
        rows = cur.fetchall()

        if not rows:
            raise HTTPException(status_code=404, detail="No expenses found.")

        amounts = [row[0] for row in rows]
        total = sum(amounts)
        average = total / len(amounts)
        highest = max(amounts)
        lowest = min(amounts)

        return {
            "username": username,
            "total_expense": round(total, 2),
            "average_expense": round(average, 2),
            "highest_expense": round(highest, 2),
            "lowest_expense": round(lowest, 2),
            "records": len(amounts)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()

@app.get("/summary/monthly", response_model=dict)
def get_monthly_summary(username: str, month: int, year: int, current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")
    
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute(
            """
            SELECT amount FROM expenses 
            WHERE username = %s AND EXTRACT(MONTH FROM date) = %s AND EXTRACT(YEAR FROM date) = %s
            """,
            (username, month, year)
        )
        rows = cur.fetchall()

        if not rows:
            raise HTTPException(status_code=404, detail="No expenses found for given month/year.")

        amounts = [row[0] for row in rows]
        total = sum(amounts)
        average = total / len(amounts)
        highest = max(amounts)
        lowest = min(amounts)

        return {
            "month": f"{month:02d}-{year}",
            "total": total,
            "average": average,
            "highest": highest,
            "lowest": lowest,
            "count": len(amounts)
        }
    finally:
        cur.close()
        conn.close()

# CSV Export Route
@app.get("/export/csv")
def export_csv(username: str, current_user: str = Depends(get_current_user)):
    if current_user != username:
        raise HTTPException(status_code=403, detail="Unauthorized user")

    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("SELECT sno, username, reason, amount, date FROM expenses WHERE LOWER(username) = LOWER(%s)", (username,))
    rows = cur.fetchall()
    cur.close()
    conn.close()

    if not rows:
        raise HTTPException(status_code=404, detail="No expenses found")

    # Create in-memory CSV
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(["S.No", "Username", "Reason", "Amount", "Date"])
    for row in rows:
        sno, username, reason, amount, date = row
        formatted_date = date.strftime("%d-%m-%Y")
        writer.writerow([sno, username, reason, amount, formatted_date])

    response = Response(content=output.getvalue(), media_type="text/csv")
    response.headers["Content-Disposition"] = f"attachment; filename={username}_expenses.csv"
    return response